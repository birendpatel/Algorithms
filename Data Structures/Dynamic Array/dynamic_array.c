/*
* Author: Biren Patel
* Description: Implementation for dynamic array abstract data type
* Note: uses non-portable GCC features, assumes x64, best with std data types.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include "dynamic_array.h"

/*******************************************************************************
* macro: darray_trace
* purpose: debugging output if DYNAMIC_ARRAY_DEBUG == 1 from dynamic_array.h
*******************************************************************************/

#define DARRAY_TRACE(fmt, ...)                                                 \
        do                                                                     \
        {                                                                      \
            if (DYNAMIC_ARRAY_DEBUG)                                           \
            printf("\n--> %s (%d): " fmt, __func__, __LINE__, __VA_ARGS__);    \
        } while(0)

/*******************************************************************************
* macro: verify_pointer
* purpose: exit if a pointer is null
* @ test : one word name of the test being performed
* @ pointer : pointer returned by some function
*******************************************************************************/

#define VERIFY_POINTER(test, pointer)                                          \
        if (pointer == NULL)                                                   \
        {                                                                      \
            fprintf(stderr, #test " fail: %s in %s\n", __func__, __FILE__);    \
            exit(EXIT_FAILURE);                                                \
        }

/*******************************************************************************
* macro: darray_header_var
* purpose: given pointer to struct member, get pointer to containing structure
*******************************************************************************/

#define DARRAY_HEADER_VAR(d) ((struct darray_header *) (((int8_t*) (d)) - 16))

/*******************************************************************************
* structure: darray_header
* purpose: hidden 16 byte structure contains array metadata
* @ queue cache : pointer to the item removed during last popleft operation
* @ capacity : current maximum size of array
* @ length : current number of elements held in array
* @ data : stores elements contained in array

     #---------------#------------#------------#-------------------#
     #  queue cache  #  capacity  #   length   #  data ----------> #
     #---------------#------------#------------#-------------------#

     \_______________________________________/  \_________________/
                  hidden metadata                  exposed array

*******************************************************************************/

struct __attribute__ ((packed)) darray_header
{
    array_item *queue_cache;
    uint32_t capacity;
    uint32_t length;
    array_item data[];
};

/*******************************************************************************
* public functions
*******************************************************************************/

darray darray_create(void)
{
    DARRAY_TRACE("creating dynamic array%c\n", ' ');
    assert(INIT_CAPACITY > 0);

    //client will receive dh->data but the rest of the struct will be hidden
    struct darray_header *dh;
    assert(sizeof(struct darray_header) == 16);

    //allocate block of memory for struct + FLA
    dh = malloc(16 + sizeof(array_item) * INIT_CAPACITY);
    VERIFY_POINTER(malloc, dh);

    //define header metadata
    dh->queue_cache = NULL;
    dh->capacity = INIT_CAPACITY;
    dh->length = 0;

    //expose array to client but keep the header hidden
    DARRAY_TRACE("dynamic array created, %d element capacity\n", dh->capacity);
    return dh->data;
}

/******************************************************************************/

void darray_destroy(darray d)
{
    assert(d != NULL);

    //define pointer to containing structure via the input pointer
    struct darray_header *dh = DARRAY_HEADER_VAR(d);

    //check that we have the stucture
    assert(dh->data[0] == *d);

    DARRAY_TRACE("destroying dynamic array "
                 "with members\n\tq cache: %p\n\tcapacity: %d\n\tlength: %d\n",
                 (void*) dh->queue_cache, dh->capacity, dh->length);

    //pointers are checking out okay, free queue cache and then memory block
    free(dh->queue_cache);
    free(dh);
    return;
}

/******************************************************************************/

int darray_len(darray d)
{
    assert(d != NULL);

    //define pointer to containing structure via the input pointer
    struct darray_header *dh = DARRAY_HEADER_VAR(d);

    //check that we have the stucture and check length in bounds
    assert(dh->data[0] == *d);
    assert(dh->length >= 0 && dh->length <= dh->capacity);

    DARRAY_TRACE("returning data length to client: %d elements", dh->length);
    return dh->length;
}


/******************************************************************************/

void darray_push(darray *d, array_item element)
{
    assert(d != NULL && *d != NULL);

    //define pointer to structure via the dereferenced input pointer
    struct darray_header *dh = DARRAY_HEADER_VAR(*d);

    //check that we have the stucture and check length in bounds
    assert(dh->data[0] == **d);
    assert(dh->length >= 0 && dh->length <= dh->capacity);

    DARRAY_TRACE("pushing element to dynamic array%c\n", ' ');

    //no space left in the allocated block to push the element
    if (dh->length == dh->capacity)
    {
        //determine new array capacity as a function of current capacity
        dh->capacity = INCREASE_CAPACITY(dh->capacity);

        assert(dh->capacity > dh->length);
        DARRAY_TRACE("increased capacity to %d\n", dh->capacity);

        //determine total bytes needed for header and data elements
        size_t new_size = 16 + sizeof(array_item) * dh->capacity;
        DARRAY_TRACE("new darray memory block of %d bytes\n", (int) new_size);

        //reallocate memory and redirect dh pointer
        struct darray_header *tmp;
        tmp = realloc(dh, new_size);
        VERIFY_POINTER(realloc, tmp);
        dh = tmp;
    }

    //space available in allocated block, go ahead and push element
    dh->data[dh->length++] = element;

    //if realloc called, dh may have moved to a new section of memory.
    //if so, need to dereference the input pointer and update address for client
    *d = dh->data;

    DARRAY_TRACE("length now at %d\n", dh->length);
    assert(dh->length >= 0 && dh->length <= dh->capacity);
    assert(dh->capacity >= dh->length); //only equal if client changed growth fx
}

/******************************************************************************/

array_item *darray_pop(darray d)
{
    assert(d != NULL);
    DARRAY_TRACE("pop requested%c\n", ' ');

    struct darray_header *dh = DARRAY_HEADER_VAR(d);

    assert(dh->data[0] == *d);
    assert(dh->length >= 0 && dh->length <= dh->capacity);

    if (dh->length == 0)
    {
        DARRAY_TRACE("nothing to pop%c\n", ' ');

        return NULL;
    }
    else
    {
        array_item *top = dh->data + (--dh->length);
        assert(dh->length >= 0);
        assert(top != NULL);

        DARRAY_TRACE("pop successful%c\n", ' ');

        return top;
    }
}

/******************************************************************************/

array_item *darray_popleft(darray d)
{
    assert(d != NULL);
    DARRAY_TRACE("popleft requested%c\n", ' ');

    struct darray_header *dh = DARRAY_HEADER_VAR(d);

    assert(dh->data[0] == *d);
    assert(dh->length >= 0 && dh->length <= dh->capacity);

    if (dh->length == 0)
    {
        //reset queue cache to NULL if necessary and return NULL like pop/peek
        DARRAY_TRACE("nothing to pop%c\n", ' ');
        dh->queue_cache = NULL;
        return NULL;
    }
    else
    {
        //empty queue cache, otherwise memory leak from previous calls
        free(dh->queue_cache);

        //reserve memory for queue cache
        dh->queue_cache = malloc(sizeof(array_item));
        VERIFY_POINTER(malloc, dh->queue_cache);

        //store copy of first item in cache block
        *dh->queue_cache = dh->data[0];
        assert(*dh->queue_cache == dh->data[0]);

        //move back all the elements in data array
        if (--dh->length != 0)
        {
            size_t n_bytes = dh->length * sizeof(array_item);

            array_item *start = memmove(dh->data, dh->data + 1, n_bytes);

            VERIFY_POINTER(memmove, start);
        }

        //good to hand pointer to popleft item back to client
        DARRAY_TRACE("popleft successful%c\n", ' ');
        return dh->queue_cache;
    }
}

/******************************************************************************/

array_item *darray_peek(darray d)
{
    assert(d != NULL);
    DARRAY_TRACE("peek requested%c\n", ' ');

    struct darray_header *dh = DARRAY_HEADER_VAR(d);

    assert(dh->data[0] == *d);
    assert(dh->length >= 0 && dh->length <= dh->capacity);

    if (dh->length == 0)
    {
        DARRAY_TRACE("nothing to peek at%c\n", ' ');

        return NULL;
    }
    else
    {
        array_item *top = dh->data + (dh->length - 1);
        assert(dh->length >= 0);
        assert(top != NULL);

        DARRAY_TRACE("peek successful%c\n", ' ');

        return top;
    }
}

/******************************************************************************/

void darray_show(darray d)
{
    assert(d != NULL);

    //define pointer to containing structure via the input pointer
    struct darray_header *dh = DARRAY_HEADER_VAR(d);

    //check that we have the structure
    assert(dh->data[0] == *d);

    //loop and print
    for(size_t i = 0; i < dh->length; ++i)
    {
        printf(FMT_STRING, d[i]);
    }

    puts("");
}
